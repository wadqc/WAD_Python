# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# PyWAD is open-source software and consists of a set of plugins written in python for the WAD-Software medical physics quality control software. 
# The WAD Software can be found on https://github.com/wadqc
# 
# The pywad package includes plugins for the automated analysis of QC images for various imaging modalities. 
# PyWAD has been originaly initiated by Dennis Dickerscheid (AZN), Arnold Schilham (UMCU), Rob van Rooij (UMCU) and Tim de Wit (AMC) 
#
# Description:
# This plugin parses the daily QC report (XML format) generated by the Siemens biograph TOF PET-CT.
# To send the data from the scanner to dcm4chee a separate tool that has to be installed on the scanner has been developed by Rob van Rooij and Dennis Dickerscheid.

__version__ = '20151221'
__author__ = 'TdW'



from dicom import tag
import xml.etree.ElementTree as ET
import lxml.etree as etree

def print_xml(xmlroot):
   for child in xmlroot:
        print '=='*20
        print child.tag, child.attrib, child.text
        
        for subchild in child:
            print '\t', subchild.tag, subchild.attrib, subchild.text

            for value in subchild:
                print '\t\t', value.tag, value.attrib, value.text
                for subvalue in value:
                    print '\t\t\t', subvalue.tag, subvalue.attrib, subvalue.text

                    for subsubvalue in subvalue:
                        print '\t\t\t\t', subsubvalue.tag, subsubvalue.attrib, subsubvalue.text

def parseqcreport(data,results,**kwargs):
    params = kwargs.get('params', None)
    p = {}
    for param in params:
        p[param.tag] = (param.text,param.attrib)

    print p
    
    status_ok=True

    relevantfile = data.getAllInstances()[0]
    xmltext = relevantfile[tag.Tag(p.get('use_private_tag')[0].split(','))]

    root = etree.fromstring(xmltext.value)
    print_xml(root)
    
    datagroup = root.find('DataGroup')
    scandate = datagroup.get('DateTime')
    
    # Region is either defined globally or per protocol; try both
    datapackage_common = root.findall(".//DataPackage[@Package_Name='ID_COMMON']")
    for data in datapackage_common:
        region_element=data.find(".//*/DataEntry[@Variable_Name='ID_REGION']/StringVariable")
        if region_element is not None:
           region=region_element.get('String_Value').replace('ID_','')

    datapackages = root.findall(".//DataPackage[@Package_Name='ID_MODE']")
    for data in datapackages:
        status_ok=True
        kV=data.find(".//*/DataEntry[@Variable_Name='ID_VOLT']/LongVariable").get('Long_Value')
        mA=data.find(".//*/DataEntry[@Variable_Name='ID_CURRENT']/LongVariable").get('Long_Value')
        region_element=data.find(".//*/DataEntry[@Variable_Name='ID_REGION']/StringVariable")
        # not present for some scanners
        if region_element is not None:
           region=region_element.get('String_Value').replace('ID_','')

        kV_ok=data.find(".//*/DataSeries[@Series_Name='ID_VOLT']/*/DataEntry").get('Variable_In_Spec')
        status_ok = status_ok and kV_ok=='INTOL'

        # not present for all mA/kV combinations
        sigma_element=data.find(".//*/DataSeries[@Series_Name='ID_SIGMA']/*/DataEntry")
        if sigma_element is not None:
           sigma_ok=sigma_element.get('Variable_In_Spec')
           sigma=sigma_element.find('DoubleVariable').get('Double_Value')
           status_ok = status_ok and sigma_ok=='INTOL'

        kV_measured=data.find(".//*/DataSeries[@Series_Name='ID_VOLT']/SeriesEntry/DataEntry/DoubleVariable").get('Double_Value')

        results.addChar('{0} {1}kV {2}mA'.format(region,kV,mA),'Passed' if status_ok else 'Failed',level=1)

        if sigma_element is not None:
           results.addFloat("{0} {1}kV {2}mA sigma".format(region,kV,mA),sigma,level=2,units='HU')
        results.addFloat("{0} {1}kV {2}mA voltage".format(region,kV,mA),kV_measured,level=2,units='kV')
